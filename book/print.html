<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>kurs pisania podstawowego systemu w języku C</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">Edycja C</li><li class="chapter-item expanded "><a href="part1.html"><strong aria-hidden="true">1.</strong> Part 1 - minimalny kernel</a></li><li class="chapter-item expanded "><a href="part2.html"><strong aria-hidden="true">2.</strong> Part 2 - testy bootowania</a></li><li class="chapter-item expanded "><a href="part3.html"><strong aria-hidden="true">3.</strong> Part 3 - Paging, zarządzanie pamięcią</a></li><li class="chapter-item expanded "><a href="part4.html"><strong aria-hidden="true">4.</strong> Part 4 - </a></li><li class="chapter-item expanded "><a href="part5.html"><strong aria-hidden="true">5.</strong> Part 5 - </a></li><li class="chapter-item expanded "><a href="part6.html"><strong aria-hidden="true">6.</strong> Part 6 - </a></li><li class="chapter-item expanded affix "><li class="part-title">Edycja RUST (TODO!)</li><li class="chapter-item expanded affix "><li class="part-title">Edycja GO (TODO!)</li><li class="chapter-item expanded affix "><li class="part-title">Edycja C++ (NEVER!)</li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">kurs pisania podstawowego systemu w języku C</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="minimalny-kernel---part-1"><a class="header" href="#minimalny-kernel---part-1">Minimalny kernel - Part 1</a></h1>
<h2 id="wprowadzenie"><a class="header" href="#wprowadzenie">Wprowadzenie</a></h2>
<p>W momencie uruchomienia komputera BIOS wykonuje self test i rutyny inicjalizacyjne. Następnym krokiem jest przekazanie kontroli do bootloadera. Bootloader zajmuje się przejściem procesora w <code>32 bit protected mode</code> (ponieważ procesor bootuje w <code>16 bit real mode</code>) a następnie znajduje kernel na nośniku urządzenia i ładuje go do pamięci .</p>
<p>My nie będziemy pisać bootloadera, jest to zbyt skomplikowane i czasochłonne, zamiast tego użyjemy <code>GRUB2</code>.</p>
<h2 id="struktura-projektu"><a class="header" href="#struktura-projektu">Struktura projektu</a></h2>
<pre><code>|---Makefile
|---build
|   | ...
|---src
    |---boot.asm
    |---multiboot_header.asm
    |---linker.ld
    |---grub.cfg
</code></pre>
<h2 id="multiboot"><a class="header" href="#multiboot">Multiboot</a></h2>
<p>Na szczęście istnieje standardowy bootloader: <a href="https://en.wikipedia.org/wiki/Multiboot_specification">multiboot</a>.</p>
<p>Aby użyć bootloader-a <code>multiboot</code> musimy zacząć pisanie naszego kernela od nagłówka składającego się z następujących pól</p>
<div class="table-wrapper"><table><thead><tr><th>Pole</th><th>Typ</th><th>Wartość</th></tr></thead><tbody>
<tr><td>magic number</td><td>uint32</td><td>0xE85250D6</td></tr>
<tr><td>architecture</td><td>uint32</td><td>0 dla i386</td></tr>
<tr><td>header length</td><td>uint32</td><td>długość headera</td></tr>
<tr><td>checksum</td><td>uint32</td><td>-(magic + architecture + header_length)</td></tr>
<tr><td>tags</td><td>nie zdefiniowane</td><td>wartości są różne w zależności od zastosowania</td></tr>
<tr><td>end tags</td><td>(uint16, uint16, uint32)</td><td>(0,0,8) - tag kończący kernel</td></tr>
</tbody></table>
</div>
<p>Konwertując do assembly x86:</p>
<blockquote>
<p>plik: src/multiboot_header.asm</p>
</blockquote>
<pre><code class="language-x86asm">section .multiboot_header
header_start:
    ; liczba magiczna
    dd 0xe85250d6                
    ; architektura 0 - tryb protected i386
    dd 0                         
    ; długość headera - używana przez multiboot do sprawdzenia sumy kontrolnej
    dd header_end - header_start 
    
    ; suma kontrolna - informuje bootloader o poprawnym działaniu
    dd 0x100000000 - (0xe85250d6 + 0 + (header_end - header_start))

    ; opcjonalne tagi (inocjacja FPU lub SSE)

    ; tagi końcowe
    dw 0    ; type
    dw 0    ; flags
    dd 8    ; size
header_end:
</code></pre>
<ul>
<li>header_start i header_end - są to tagi (label) w pliku dzięki którym assembler będzie za nas określał długość headera</li>
<li>dd - 'define double' określa dowolną zmienną 32 bitową która będzie bezpośrednio wkompilowana w binarkę</li>
<li>dw - 'define word' to samo co dd tylko dla 16 bitów</li>
</ul>
<h2 id="boot"><a class="header" href="#boot">Boot</a></h2>
<p>Aby nasz kernel mógł wystartować musi istnieć jakiś kod który będzie mógł być wywołany przez multiboot</p>
<blockquote>
<p>plik: src/boot.asm</p>
</blockquote>
<pre><code class="language-x86asm">; definicja miejsca zaczęcia programu
global  start

section .text

; informacja dla kompilatora o tym że wszystkie poniższe instrukcje
; muszą być zakodowane w systemie 32 bitowym, stało rozmiarowym
bits    32
start:
    ; wypisanie "OK" na ekranie
    mov dword [0xb8000], 0x2f4b2f4f

    ; hlt - halt
    ; zatrzymuje działanie procesora
    hlt
</code></pre>
<p>Wypisanie "OK" - wypisanie czegokolwiek na tym etapie polega na manualnym wpisywaniu danych do buforu VGA, docelowo napiszemy do tego minimalny driver monolityczny (wbudowany w jądro).</p>
<p>Instrukcja <code>mov dword [addr], data</code> powoduje wpisanie danych o rozmiarze dword (32 bit) do podanego adresu. W tym przypadkiem adresem 'addr' jest 0xb8000, czyli adres buforu VGA, nastomiast dane to zakodowany w odpowiedni sposób tekst wraz z kolorami. Jeden znak w tekście defuniuje się jako 4 bity koloru tła, 4 bity koloru tekstu, 8 bitów znaku ASCII. Powyższy tekst jest zakodowany w następujący sposób:</p>
<ul>
<li>2f - biały znak z zielonym tłem</li>
<li>4b - O</li>
<li>2f - ponownie biały znak z zielonym tłęm</li>
<li>4f - K</li>
</ul>
<h2 id="kompilacja"><a class="header" href="#kompilacja">Kompilacja</a></h2>
<p>W celu automatyzacji kompilacji przygotowałem następujący <a href="https://github.com/PTFOPlayer/kurs_system_c-pl/blob/main/part1/Makefile">Makefile</a> w który nie będę się zagłębiał.</p>
<p>Natomiast zwrócę uwagę na pliki <code>linker.ld</code> oraz krótko do czego służy <code>grub.cfg</code></p>
<blockquote>
<p>plik: src/linker.ld</p>
</blockquote>
<pre><code class="language-ld">
ENTRY(start)

SECTIONS {
    . = 1M;

    .boot :
    {
        /* 
            umieszczenie sekcji multiboot na początku programu
            z tego momentu zaczyna się działanie systemu
        */
        *(.multiboot_header)
    }

    .text :
    {
        /*
            główna sekcja programu
        */
        *(.text)
    }
}
</code></pre>
<p>Plik linker.ld definiuje nam w jakie miejsca jest wstawiana która częśc programu. Na poczatku mamy <code>. = 1M;</code> jest to ignorowanie pierwszego MiB miejsca na nośniku, ponieważ znajdują się tam specjalne adresy. Następnie mamy sekcję <code>.boot</code> w której będzie informacja o standardzie multiboot a dopiero na końcu przechodzimy do właściwego kernela w sekcji <code>.text</code>.</p>
<blockquote>
<p>plik: src/grub.cfg</p>
</blockquote>
<pre><code>set timeout=0
set default=0

menuentry "os" {
    multiboot2 /boot/kernel.bin
    boot
}
</code></pre>
<p>Ten plik definiuje nam w jaki sposób ma być stworzony plik ISO naszego systemu. <code>menuentry</code> oznacza nazwę która będzie się pojawiać w tabeli grub2, następnie w klamerkach definiujemy ścieżkę do binarki kernela oraz w następnej linijce nazwę punktu wejścia.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testy-poprawnego-bootowania---part-2"><a class="header" href="#testy-poprawnego-bootowania---part-2">Testy poprawnego bootowania - Part 2</a></h1>
<h2 id="wprowadzenie-1"><a class="header" href="#wprowadzenie-1">Wprowadzenie</a></h2>
<p>Jesteśmy już w trybie protected oraz posiadamy kontrolę nad tym co robi procesor. Mogli byśmy już przechodzić do trybu 64 bitowego, ale procesory mają to do siebie że mają różne specyfikacje, funkcjonalności, oraz zestawy instrukcji.</p>
<p>Z tego powodu musimy napisać odpowiednie testy które pozwolą na poprawne przejście do trybu 64 bit a w przeciwnym razie HALT procesora.</p>
<h2 id="struktura-projektu-1"><a class="header" href="#struktura-projektu-1">Struktura projektu</a></h2>
<p>Struktura projektu pozostaje bez zmian względem poprzedniej części. W następnej przeniesiemy check-i do oddzilenych plików</p>
<h2 id="inicjacja-stosu"><a class="header" href="#inicjacja-stosu">Inicjacja stosu</a></h2>
<p>Do wykonania niektórych testów będziemy potrzebować stosu, niestety nie mamy pod nami systemu który może nam przydzielić pamięć a więc musimy sami zdecydować ile jej potrzebujemy i zadeklarować tą ilość w sekcji <code>.bss</code></p>
<blockquote>
<p>plik: src/boot.asm</p>
</blockquote>
<pre><code class="language-x86asm">section .bss
stack_bottom:
    resb 64
stack_top:
</code></pre>
<p>Tagi <code>stack_bottom</code> i <code>stack_top</code> ułatwiają nam znalezienie granic stosu, na ten moment rezerwujemy tylko 64 bajty, potem będziemy modyfikować tą wartośc.</p>
<p>Teraz musimy zainicjować <code>ESP</code> aby móc używać instrukcji służących do wypychania i ściągania danych ze stacku.</p>
<blockquote>
<p>plik: src/boot.asm</p>
</blockquote>
<pre><code class="language-x86asm">...

start:
    ; w procesorach potomnych dla i386 stack zaczyna się od jego góry i kończy na spodzie
    mov  esp, stack_top
    
...
</code></pre>
<h2 id="test-multiboot"><a class="header" href="#test-multiboot">Test Multiboot</a></h2>
<p>Test ten jest odpowiedzialny za sprawdzenie czy system został odpalony z użyciem multiboot (grub), jest to ważne ponieważ potem można wykorzystywać informację o tym do pozyskania dodatkowych informacji o dostępnym sprzęcie.</p>
<p>Z dokumentacji możemy się dowiedzieć że multiboot na zakończenie swojej pracy ładuje do rejestru <code>EAX</code> wartość <code>0x36d76289</code>, jeśli jest tam inna wartość to nastąpił jakiegoś rodzaju błąd lub nie kernel nie został uruchomiony z użyciem multiboot</p>
<blockquote>
<p>plik: src/boot.asm</p>
</blockquote>
<pre><code class="language-x86asm">multiboot_check:
    cmp eax, 0x36d76289
    
    ; jeśli EAX nie jest równe powyższej wartości to przechodzimy do błędu procesora
    jne .multiboot_error
    ret
 
    ; jeśli procedura nie zadziała poprawnie musimy zgłosić błąd
.multiboot_error:
    mov  al, "M"
    call error
</code></pre>
<h2 id="test-cpuid"><a class="header" href="#test-cpuid">Test CPUID</a></h2>
<p>Sprawdzenie obecności CPUID wykonuje się poprzed obrót bitu 21 w rejestrze FLAGS.
Jeżeli uda nam się poprawnie obrócić bit, wpisać wartość do rejestru FLAGS i pobrać ją ponownie i w trakcie tej operacji bit 21 wróci do swojego początkowego stanu to zestaw instrukcji CPUID jest dostępny.</p>
<blockquote>
<p>plik: src/boot.asm</p>
</blockquote>
<pre><code class="language-x86asm">cpuid_check:
    ; skopiowane FLAGS do EAX używając stack-u
    ; pushfd wypycha FLAGS na stack
    pushfd
    pop eax

    ; kopiowanie FLAGS z EAX do ECX
    mov ecx, eax

    ; obrócenie bitu 21
    xor eax, 1 &lt;&lt; 21

    ; ustawienie rejestru FLAGS na wartość z EAX z obróconym bitem 21
    push eax
    popfd

    ; ponowne skopiowanie FLAGS do EAX, jeśli bit się obrócił z powrotem to posiadamy CPUID
    pushfd
    pop eax

    ; przywrócenie początkowej wersji rejestru FLAGS
    push ecx
    popfd

    ; jeżeli EAX i ECX są równe to znaczy że bit 21 nie został obrucony co znaczy że nie posiadamy CPUID
    cmp eax, ecx
    je  .cpuid_error
    ret
.cpuid_error:
    mov al, "C"
    jmp error

</code></pre>
<h2 id="test-longmode"><a class="header" href="#test-longmode">Test Longmode</a></h2>
<p>Ostatnim krokiem dla nas jest sprawdzenie czy dostępny jest tryb 64 bitowy. Wywołująć instrukcję <code>cpuid</code> z argumentem <code>0x80000000</code> spowoduje sprawdzenie maksymalnej dostępnej wersji CPUID w naszym procesorze, dla naszych potrzeb wystarczy wersja <code>0x80000001</code>.</p>
<p>Instrukcja <code>Cpuid</code> z argumentem <code>0x80000001</code> ładuje do głównych 4 rejesetrów dużo informacji na temat procesora, w tym informacje o dostępnych trybach działania oraz posiadanych zestawach instrukcji. Po wywołaniu tej instrukcji w rejestrze <code>EDX</code> na bicie 29 znajduje się informacja czy longmode jest dostępny.</p>
<blockquote>
<p>plik: src/boot.asm</p>
</blockquote>
<pre><code class="language-x86asm">long_mode_check:
    ; sprawdzenie czy rozszerzone informacje o pocesorze są dostępne
    mov eax, 0x80000000
    cpuid                  
    ; minimalna wersja z longmode to 0x80000001, jeśli jest mniej to wywołujemy błąd
    cmp eax, 0x80000001
    jb  .long_mode_error

    ; sprawdzenie czy longmode jest dostępny
    ; argument dla CPUID do uzyskania rozszezrzonych informacji 
    mov eax, 0x80000001
    cpuid

    ; sprawdznie czy LM-bit jest ustawiony w EDX, jeśli nie to wywołujemy błąd
    test edx, 1 &lt;&lt; 29
    jz   .long_mode_error
    ret
.long_mode_error:
    mov al, "L"
    jmp error
</code></pre>
<h2 id="wykorzystanie-testów"><a class="header" href="#wykorzystanie-testów">Wykorzystanie testów</a></h2>
<p>Testy już są napisane teraz trzeba je wywołać w odpowiedniej kolejności.</p>
<ol>
<li>Multiboot</li>
<li>CPUID</li>
<li>Longmode</li>
</ol>
<p>A więc po ich dodaniu w <code>start</code> będzie wyglądał następująco:</p>
<blockquote>
<p>plik: src/boot.asm</p>
</blockquote>
<pre><code class="language-x86asm">...

start:
    ; w procesorach potomnych dla i386 stack zaczyna się od jego góry i kończy na spodzie
    mov  esp, stack_top

    ; wywołanie procedury sprawdzenia multiboot
    call multiboot_check
    
    ; wywołanie procedury sprawdzenia CPUID
    call cpuid_check

    ; wywołanie prrocedury sprawdzenia longmode
    call long_mode_check

...
</code></pre>
<h2 id="uruchomienie"><a class="header" href="#uruchomienie">Uruchomienie</a></h2>
<p>Jeżeli wszystko zadziałało poprawnie, po wykonaniu komendy <code>make run</code> powinniśmy zobaczyć taki obraz w maszynie:</p>
<p><img src="./photos/part2_working.png" alt="image" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="paging---part-3"><a class="header" href="#paging---part-3">Paging - Part 3</a></h1>
<p>Paging, jest to metoda zarządzania pamięcią która oddziela pamięć wirtualną od pamięci fizycznej. Przestrzeń adresowa jest podzielona na równego rozmiaru "strony" i <code>page table</code> definiuje który adres wirtualny odpowiada kßórego madresowi fizycznemu.</p>
<p>W <code>x86_64</code> rozmair strony to 4096 bajtów i 4 poziomiwe "strony", każda ze "stron" posiada 512, 8 bajtowych sektorów.</p>
<p><img src="./photos/paging.png" alt="image" /></p>
<h2 id="struktura-sektoru-strony"><a class="header" href="#struktura-sektoru-strony">Struktura sektoru strony</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Bity</th><th>Nazwa</th><th>Opis</th></tr></thead><tbody>
<tr><td>0</td><td>present</td><td>strona znajduje się w pamięci</td></tr>
<tr><td>1</td><td>writable</td><td>można zapisać do strony</td></tr>
<tr><td>2</td><td>user accesible</td><td>dostępna na poziomie urzytkownika</td></tr>
<tr><td>3</td><td>write through caching</td><td>bezpośredni zapis</td></tr>
<tr><td>4</td><td>no cache</td><td>nie urzywaj pamięci cache</td></tr>
<tr><td>5</td><td>accesed</td><td>CPU ustawia ten bit kiedy strona jest w użyciu</td></tr>
<tr><td>6</td><td>dirty</td><td>CPU ustawia ten bit kiedy strona jest w trakcie zapisu</td></tr>
<tr><td>7</td><td>huge page/null</td><td>strona rozszerzona do 2MB w Page Level 2 i do 1 GB w Page Level 3</td></tr>
<tr><td>8</td><td>global</td><td>strona nie jest zapisywana jeśli znajduje się w pamięci cache</td></tr>
<tr><td>9-11</td><td>available</td><td>dostępne dla systemu</td></tr>
<tr><td>12-52</td><td>-</td><td>pominięte, ze względu na unikalnośc adresów</td></tr>
<tr><td>52-62</td><td>available</td><td>dostępne dla systemu</td></tr>
<tr><td>63</td><td>no execute</td><td>zakaz wykonywania kodu z tej strony (bit NXE)</td></tr>
</tbody></table>
</div>
<h2 id="ograniczenia"><a class="header" href="#ograniczenia">Ograniczenia</a></h2>
<p>Używając bitu <code>huge page</code> na stronach poziomu trzeciego moglibyśmy mapować pierwszy 1GB naszego kernela do pojedyńczej strony co bo znacznie poprawiło jego responsywność i pozwoliło procesorowi na ustalenie lepszych zasad cache-owania. Niestety nie możemy tego zrobić ponieważ <code>huge page</code> na L3 został wprowadzony dopiero w generacji <code>Westmere</code> (seria Xeon), <code>Haswell</code> (seria Core I 4 gen), a więc aby zagwarantować kompatybilnośc z starszymi procesorami i maszynami wirtualnymi będziemy stosować bit <code>huge page</code> na stronach L2</p>
<p>Strony są przeszukiwane idąc od L4 do L1, przez co najpierw jest przeszukiwana najdawniej alokowana pamięć.</p>
<p>Paging nie oznacza możliwości alokacji na heap. Do tego trzeba dalej napisać alokator (nie będziemy tego robić).</p>
<p>Paging nie jest zawsze taki sam, w przypadku bardzo dużej ilości pamięci inaczej się rozkłada strony. Są również bardziej zaawansowane metody translacji adresów.</p>
<p>Paging jest ściśle wymagany przez tryb 64 bitowy, bez niego procesor nie wejdzie w ten tryb i wykona przerwanie które kończy się instrukcją <code>halt</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="part-4"><a class="header" href="#part-4">Part 4</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="part-5"><a class="header" href="#part-5">Part 5</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="part-6--"><a class="header" href="#part-6--">Part 6 -</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
